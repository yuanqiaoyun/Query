这里的头部组件和主要部件以及底部组件其实是兄弟之间的关系，但是这里就是为了练习父子组件之间的传值，
所以这里就用app.vue组件和他们传值，所以数据就应该是定义在app.vue中去的

2.底部全选的逻辑。
2.1 首先（设置也即get方法中，别的变化引起他的变化）把全选的属性设置成计算属性。
        逻辑就是 finishedCount 和数组本身的长度  
        finishedCount === todos.length; （值得好好一记） 
        到后来又发现小bug的时候又&&this.todos .legth>0;  (好好琢磨。)
        然后再return 给这个属性（这个属性要的就是一个布尔值).
2.2 然后 （本身的变化引起别人的变化,set方法，把本身的值暴露给外界)。
         在该业务或者逻辑下，它的变化要么是让上面的都不选中或者都选中。
         所以遍历数组，让其他的值都等于它。

3.本身写完之后有一个bug 就是清除已完成任务的时候会留一个没有清除。

4.本地化存储（数据持久化） localStorage和sessionStorage
4.1:所有的数据都是在app.vue中的。所以关于数据的操作都应该在这里。
   4.1.1: 一般对网络的数据的存和取都会封装一些工具类。所以会建一个文件夹专门放一些工具(在src中)。
          eg:utils --- 工具文件夹。
   4.1.2:工具类写好以后，要在组件中用就需要先引入。
5.深度监视
   5.1:场景：在本地化存储的时候，去读取数据的时候还好，只要拿过来取读就好了，
            存的话涉及的东西就比较多了。数据的改变以及数据状态的改变都要把这些改变存储到缓存中去，
            可以每改变一次去调用一次saveTodo函数
          （但是想想加入上千的元素都会改变数据，saveTodo就要被调用千万次，不现实）。
           vue给我门提供了一个这样的钩子函数  叫Watch。
   5.2:watch的使用。 watch是个属性，而不是钩子函数。

//.注释的内容:添加本地存储化以及修复所有记录都清除以后，全选的复选框还是选中的状态。


  第二：   第二版
1.修改自定义事件
   1.1：自定义事件适用的场景是 子组件需要向父组件传递内容的时候。
        本例中的头部就是典型的子组件向父组传值的。
   1.2:自定义事件的流程：
        子组件通过$emit(),向父组件传递内容。父组件监听。
        ---->父组件监听的两种方式：1):通过$on,2):ref。
        这里使用的是ref的方式。
        1.2.1:父组件的监听一般是在组件挂在完成后，开始监听。
    

          